/*           geometry.js

    Simple geometry package using MV.js
    Supports:

            sphere object
            material object
            light object
            texture object
*/

"use strict";

/*    Sphere object

      Usage: var mySphere = sphere(numSubdivisions);

      Sphere of radius 0.5 generated by recursive subdivision of tetrahedron
        producing 4**(numsubdivisions+1) triangles

     default: sphere(3)

      Attributes:  The following each have  values for rendering the triangles
              approximating the sphere

            TextureCoordinates
            TriangleVertices
            TriangleVertexColors
            TriangleFaceColors
            TriangleNormals

Methods:

            translate(dx, dy, dz)
            scale(sz, sy, sz)
            rotate(angle, [axisx, axisy, axisz])


*/

function sphere(numSubdivisions) {

var subdivisions = 3;
if(numSubdivisions) subdivisions = numSubdivisions;


var data = {};

//var radius = 0.5;

var sphereVertexCoordinates = [];
var sphereVertexCoordinatesNormals = [];
var sphereVertexColors = [];
var sphereTextureCoordinates = [];
var sphereNormals = [];

var va = vec4(0.0, 0.0, -1.0,1);
var vb = vec4(0.0, 0.942809, 0.333333, 1);
var vc = vec4(-0.816497, -0.471405, 0.333333, 1);
var vd = vec4(0.816497, -0.471405, 0.333333,1);

function triangle(a, b, c) {

    //  positions 
    sphereVertexCoordinates.push([a[0], a[1], a[2], 1]);
    sphereVertexCoordinates.push([b[0], b[1], b[2], 1]);
    sphereVertexCoordinates.push([c[0], c[1], c[2], 1]);

    //  normals 
    sphereNormals.push([a[0], a[1], a[2]]);
    sphereNormals.push([b[0], b[1], b[2]]);
    sphereNormals.push([c[0], c[1], c[2]]);

    // debug colours  
    sphereVertexColors.push([(1+a[0])/2, (1+a[1])/2, (1+a[2])/2, 1]);
    sphereVertexColors.push([(1+b[0])/2, (1+b[1])/2, (1+b[2])/2, 1]);
    sphereVertexColors.push([(1+c[0])/2, (1+c[1])/2, (1+c[2])/2, 1]);

    /* 
       NEW: equirectangular UVs
       u = 0.5 + atan2(z, x)/(2π)
       v = 0.5 − asin(y)/π
    */
    function uv(p){
        return [
            0.5 + Math.atan2(p[2], p[0]) / (2 * Math.PI),
            0.5 - Math.asin (p[1])        /      Math.PI
        ];
    }

    sphereTextureCoordinates.push( uv(a) );
    sphereTextureCoordinates.push( uv(b) );
    sphereTextureCoordinates.push( uv(c) );
}




function divideTriangle(a, b, c, count) {
    if ( count > 0 ) {

        var ab = mix( a, b, 0.5);
        var ac = mix( a, c, 0.5);
        var bc = mix( b, c, 0.5);

        ab = normalize(ab, true);
        ac = normalize(ac, true);
        bc = normalize(bc, true);

        divideTriangle( a, ab, ac, count - 1 );
        divideTriangle( ab, b, bc, count - 1 );
        divideTriangle( bc, c, ac, count - 1 );
        divideTriangle( ab, bc, ac, count - 1 );
    }
    else {
        triangle( a, b, c );
    }
}


function tetrahedron(a, b, c, d, n) {
    divideTriangle(a, b, c, n);
    divideTriangle(d, c, b, n);
    divideTriangle(a, d, b, n);
    divideTriangle(a, c, d, n);
}

tetrahedron(va, vb, vc, vd, subdivisions);


function translate(x, y, z){
   for(var i=0; i<sphereVertexCoordinates.length; i++) {
     sphereVertexCoordinates[i][0] += x;
     sphereVertexCoordinates[i][1] += y;
     sphereVertexCoordinates[i][2] += z;
   }
   return this;
}

function scale(sx, sy, sz){
    for(var i=0; i<sphereVertexCoordinates.length; i++) {
        sphereVertexCoordinates[i][0] *= sx;
        sphereVertexCoordinates[i][1] *= sy;
        sphereVertexCoordinates[i][2] *= sz;
        sphereNormals[i][0] /= sx;
        sphereNormals[i][1] /= sy;
        sphereNormals[i][2] /= sz;
    }
    return this;
}

function radians( degrees ) {
    return degrees * Math.PI / 180.0;
}

function rotate( angle, axis) {

    var d = Math.sqrt(axis[0]*axis[0] + axis[1]*axis[1] + axis[2]*axis[2]);

    var x = axis[0]/d;
    var y = axis[1]/d;
    var z = axis[2]/d;

    var c = Math.cos( radians(angle) );
    var omc = 1.0 - c;
    var s = Math.sin( radians(angle) );

    var mat = [
        [ x*x*omc + c,   x*y*omc - z*s, x*z*omc + y*s ],
        [ x*y*omc + z*s, y*y*omc + c,   y*z*omc - x*s ],
        [ x*z*omc - y*s, y*z*omc + x*s, z*z*omc + c ]
    ];

    for(var i=0; i<sphereVertexCoordinates.length; i++) {
          var u = [0, 0, 0];
          var v = [0, 0, 0];
          for( var j =0; j<3; j++)
           for( var k =0 ; k<3; k++) {
              u[j] += mat[j][k]*sphereVertexCoordinates[i][k];
              v[j] += mat[j][k]*sphereNormals[i][k];
            };
           for( var j =0; j<3; j++) {
             sphereVertexCoordinates[i][j] = u[j];
             sphereNormals[i][j] = v[j];
           };
    }
    return this;
}
//for(var i =0; i<sphereVertexCoordinates.length; i++) console.log(sphereTextureCoordinates[i]);

data.TriangleVertices = sphereVertexCoordinates;
data.TriangleNormals = sphereNormals;
data.TriangleVertexColors = sphereVertexColors;
data.TextureCoordinates = sphereTextureCoordinates;
data.rotate = rotate;
data.translate = translate;
data.scale = scale;
return data;

}

//______________________________________________________________________

/*
          Gold Colored materialAmbient

          Useage: myMaterial = goldMaterial();
*/

function goldMaterial() {
  var data  = {};
  data.materialAmbient = vec4( 1.0, 0.0, 1.0, 1.0 );
  data.materialDiffuse = vec4( 1.0, 0.8, 0.0, 1.0);
  data.materialSpecular = vec4( 1.0, 0.8, 0.0, 1.0 );
  data.materialShininess = 100.0;
  return data;
}

//_________________________________________________________________________________

/*
          Light Object

          Usage: var myLight = light0()

          Distant light with ambient, diffuse and specular components
*/
function light0() {
  var data = {};
  data.lightPosition = vec4(0.0, 0.0, 10.0, 0.0 );;
  data.lightAmbient = vec4(0.2, 0.2, 0.2, 1.0 );
  data.lightDiffuse = vec4( 1.0, 1.0, 1.0, 1.0 );
  data.lightSpecular = vec4(1.0, 1.0, 1.0, 1.0 );
  data.lightShineness = 10;
  return data;
}

//_________________________________________________________________________________

/*
      Checkerboard texture

      Usage: var myTexture = checkerboardTexture(size, rows, columns)

      creates a size x size texture with a checkerboard of nrows x ncolumns

      default: checkerboard(128, 8 8)
*/


function checkerboardTexture(size, rows, columns)
{
  var texSize = 128;
  if(size)  texSize = size;

  var nrows = 8;
  if(rows) nrows = rows;
  var ncolumns = nrows;
  if(columns) ncolumns = columns;

  // Create a checkerboard pattern using floats

  var image = new Uint8Array(4*texSize*texSize);

  for ( var i = 0; i < texSize; i++ )
    for ( var j = 0; j < texSize; j++ ) {
        var patchx = Math.floor(i/(texSize/ncolumns));
        var patchy = Math.floor(j/(texSize/nrows));

        var c = (patchx%2 !== patchy%2 ? 255 : 0);

        image[4*i*texSize+4*j] = c;
        image[4*i*texSize+4*j+1] = c;
        image[4*i*texSize+4*j+2] = c;
        image[4*i*texSize+4*j+3] = 255;
  }

  var texture = gl.createTexture();
  gl.activeTexture( gl.TEXTURE0 );
  gl.bindTexture( gl.TEXTURE_2D, texture );
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize, texSize, 0,
  gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.generateMipmap( gl.TEXTURE_2D );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,
          gl.NEAREST_MIPMAP_LINEAR );
  gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

  return texture;
}